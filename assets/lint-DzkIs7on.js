import{C as B}from"./codemirror-DvuMJ4D3.js";import{K as c,G as p,i as S,j as fe,k as V,n as de,l as C,s as w,t as h,m as _,p as T,o as G,q as D,u as N,D as E,O as q,v as we,w as Re,x as b,y as F,z as I,A,B as te,C as pe,E as k,F as $e,H as Fe,I as Ve,J as Ce,L,M as Ae,N as ke,P as Le,Q as Ue,S as re,T as me,U as ge,V as ve,W as Pe,X as Me,Y as je,Z as Ye,$ as Ge,a0 as Be}from"./index-8cVzSU9l.js";import{R as Ne,P as U}from"./Range-CZNrBk8u.js";import"./codemirror-SoMxHusx.js";function qe(n){return n.kind===c.OPERATION_DEFINITION||n.kind===c.FRAGMENT_DEFINITION}function Xe(n){return n.kind===c.SCHEMA_DEFINITION||K(n)||n.kind===c.DIRECTIVE_DEFINITION}function K(n){return n.kind===c.SCALAR_TYPE_DEFINITION||n.kind===c.OBJECT_TYPE_DEFINITION||n.kind===c.INTERFACE_TYPE_DEFINITION||n.kind===c.UNION_TYPE_DEFINITION||n.kind===c.ENUM_TYPE_DEFINITION||n.kind===c.INPUT_OBJECT_TYPE_DEFINITION}function Qe(n){return n.kind===c.SCHEMA_EXTENSION||Ee(n)}function Ee(n){return n.kind===c.SCALAR_TYPE_EXTENSION||n.kind===c.OBJECT_TYPE_EXTENSION||n.kind===c.INTERFACE_TYPE_EXTENSION||n.kind===c.UNION_TYPE_EXTENSION||n.kind===c.ENUM_TYPE_EXTENSION||n.kind===c.INPUT_OBJECT_TYPE_EXTENSION}function Te(n){return{Document(t){for(const e of t.definitions)if(!qe(e)){const r=e.kind===c.SCHEMA_DEFINITION||e.kind===c.SCHEMA_EXTENSION?"schema":'"'+e.name.value+'"';n.reportError(new p(`The ${r} definition is not executable.`,{nodes:e}))}return!1}}}function Je(n){return{Field(t){const e=n.getParentType();if(e&&!n.getFieldDef()){const s=n.getSchema(),i=t.name.value;let o=S("to use an inline fragment on",He(s,e,i));o===""&&(o=S(We(e,i))),n.reportError(new p(`Cannot query field "${i}" on type "${e.name}".`+o,{nodes:t}))}}}}function He(n,t,e){if(!fe(t))return[];const r=new Set,s=Object.create(null);for(const o of n.getPossibleTypes(t))if(o.getFields()[e]){r.add(o),s[o.name]=1;for(const a of o.getInterfaces()){var i;a.getFields()[e]&&(r.add(a),s[a.name]=((i=s[a.name])!==null&&i!==void 0?i:0)+1)}}return[...r].sort((o,a)=>{const l=s[a.name]-s[o.name];return l!==0?l:V(o)&&n.isSubType(o,a)?-1:V(a)&&n.isSubType(a,o)?1:de(o.name,a.name)}).map(o=>o.name)}function We(n,t){if(C(n)||V(n)){const e=Object.keys(n.getFields());return w(t,e)}return[]}function Ke(n){return{InlineFragment(t){const e=t.typeCondition;if(e){const r=h(n.getSchema(),e);if(r&&!_(r)){const s=T(e);n.reportError(new p(`Fragment cannot condition on non composite type "${s}".`,{nodes:e}))}}},FragmentDefinition(t){const e=h(n.getSchema(),t.typeCondition);if(e&&!_(e)){const r=T(t.typeCondition);n.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,{nodes:t.typeCondition}))}}}}function ze(n){return{...Ze(n),Argument(t){const e=n.getArgument(),r=n.getFieldDef(),s=n.getParentType();if(!e&&r&&s){const i=t.name.value,o=r.args.map(l=>l.name),a=w(i,o);n.reportError(new p(`Unknown argument "${i}" on field "${s.name}.${r.name}".`+S(a),{nodes:t}))}}}}function Ze(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():G;for(const o of r)t[o.name]=o.args.map(a=>a.name);const s=n.getDocument().definitions;for(const o of s)if(o.kind===c.DIRECTIVE_DEFINITION){var i;const a=(i=o.arguments)!==null&&i!==void 0?i:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const f=u.name.value;if(!l.includes(f)){const d=w(f,l);n.reportError(new p(`Unknown argument "${f}" on directive "@${a}".`+S(d),{nodes:u}))}}return!1}}}function xe(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():G;for(const i of r)t[i.name]=i.locations;const s=n.getDocument().definitions;for(const i of s)i.kind===c.DIRECTIVE_DEFINITION&&(t[i.name.value]=i.locations.map(o=>o.value));return{Directive(i,o,a,l,u){const f=i.name.value,d=t[f];if(!d){n.reportError(new p(`Unknown directive "@${f}".`,{nodes:i}));return}const m=en(u);m&&!d.includes(m)&&n.reportError(new p(`Directive "@${f}" may not be used on ${m}.`,{nodes:i}))}}}function en(n){const t=n[n.length-1];switch("kind"in t||D(!1),t.kind){case c.OPERATION_DEFINITION:return nn(t.operation);case c.FIELD:return E.FIELD;case c.FRAGMENT_SPREAD:return E.FRAGMENT_SPREAD;case c.INLINE_FRAGMENT:return E.INLINE_FRAGMENT;case c.FRAGMENT_DEFINITION:return E.FRAGMENT_DEFINITION;case c.VARIABLE_DEFINITION:return E.VARIABLE_DEFINITION;case c.SCHEMA_DEFINITION:case c.SCHEMA_EXTENSION:return E.SCHEMA;case c.SCALAR_TYPE_DEFINITION:case c.SCALAR_TYPE_EXTENSION:return E.SCALAR;case c.OBJECT_TYPE_DEFINITION:case c.OBJECT_TYPE_EXTENSION:return E.OBJECT;case c.FIELD_DEFINITION:return E.FIELD_DEFINITION;case c.INTERFACE_TYPE_DEFINITION:case c.INTERFACE_TYPE_EXTENSION:return E.INTERFACE;case c.UNION_TYPE_DEFINITION:case c.UNION_TYPE_EXTENSION:return E.UNION;case c.ENUM_TYPE_DEFINITION:case c.ENUM_TYPE_EXTENSION:return E.ENUM;case c.ENUM_VALUE_DEFINITION:return E.ENUM_VALUE;case c.INPUT_OBJECT_TYPE_DEFINITION:case c.INPUT_OBJECT_TYPE_EXTENSION:return E.INPUT_OBJECT;case c.INPUT_VALUE_DEFINITION:{const e=n[n.length-3];return"kind"in e||D(!1),e.kind===c.INPUT_OBJECT_TYPE_DEFINITION?E.INPUT_FIELD_DEFINITION:E.ARGUMENT_DEFINITION}default:D(!1,"Unexpected kind: "+N(t.kind))}}function nn(n){switch(n){case q.QUERY:return E.QUERY;case q.MUTATION:return E.MUTATION;case q.SUBSCRIPTION:return E.SUBSCRIPTION}}function tn(n){return{FragmentSpread(t){const e=t.name.value;n.getFragment(e)||n.reportError(new p(`Unknown fragment "${e}".`,{nodes:t.name}))}}}function rn(n){const t=n.getSchema(),e=t?t.getTypeMap():Object.create(null),r=Object.create(null);for(const i of n.getDocument().definitions)K(i)&&(r[i.name.value]=!0);const s=[...Object.keys(e),...Object.keys(r)];return{NamedType(i,o,a,l,u){const f=i.name.value;if(!e[f]&&!r[f]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&sn(m);if(g&&ie.includes(f))return;const v=w(f,g?ie.concat(s):s);n.reportError(new p(`Unknown type "${f}".`+S(v),{nodes:i}))}}}}const ie=[...we,...Re].map(n=>n.name);function sn(n){return"kind"in n&&(Xe(n)||Qe(n))}function an(n){let t=0;return{Document(e){t=e.definitions.filter(r=>r.kind===c.OPERATION_DEFINITION).length},OperationDefinition(e){!e.name&&t>1&&n.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:e}))}}}const on=3;function ln(n){function t(e,r=Object.create(null),s=0){if(e.kind===c.FRAGMENT_SPREAD){const i=e.name.value;if(r[i]===!0)return!1;const o=n.getFragment(i);if(!o)return!1;try{return r[i]=!0,t(o,r,s)}finally{r[i]=void 0}}if(e.kind===c.FIELD&&(e.name.value==="fields"||e.name.value==="interfaces"||e.name.value==="possibleTypes"||e.name.value==="inputFields")&&(s++,s>=on))return!0;if("selectionSet"in e&&e.selectionSet){for(const i of e.selectionSet.selections)if(t(i,r,s))return!0}return!1}return{Field(e){if((e.name.value==="__schema"||e.name.value==="__type")&&t(e))return n.reportError(new p("Maximum introspection depth exceeded",{nodes:[e]})),!1}}}function un(n){const t=Object.create(null),e=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(i){return s(i),!1}};function s(i){if(t[i.name.value])return;const o=i.name.value;t[o]=!0;const a=n.getFragmentSpreads(i.selectionSet);if(a.length!==0){r[o]=e.length;for(const l of a){const u=l.name.value,f=r[u];if(e.push(l),f===void 0){const d=n.getFragment(u);d&&s(d)}else{const d=e.slice(f),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");n.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}e.pop()}r[o]=void 0}}}function cn(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s}of r){const i=s.name.value;t[i]!==!0&&n.reportError(new p(e.name?`Variable "$${i}" is not defined by operation "${e.name.value}".`:`Variable "$${i}" is not defined.`,{nodes:[s,e]}))}}},VariableDefinition(e){t[e.variable.name.value]=!0}}}function Ie(n){const t=[],e=[];return{OperationDefinition(r){return t.push(r),!1},FragmentDefinition(r){return e.push(r),!1},Document:{leave(){const r=Object.create(null);for(const s of t)for(const i of n.getRecursivelyReferencedFragments(s))r[i.name.value]=!0;for(const s of e){const i=s.name.value;r[i]!==!0&&n.reportError(new p(`Fragment "${i}" is never used.`,{nodes:s}))}}}}}function fn(n){let t=[];return{OperationDefinition:{enter(){t=[]},leave(e){const r=Object.create(null),s=n.getRecursiveVariableUsages(e);for(const{node:i}of s)r[i.name.value]=!0;for(const i of t){const o=i.variable.name.value;r[o]!==!0&&n.reportError(new p(e.name?`Variable "$${o}" is never used in operation "${e.name.value}".`:`Variable "$${o}" is never used.`,{nodes:i}))}}},VariableDefinition(e){t.push(e)}}}function z(n){switch(n.kind){case c.OBJECT:return{...n,fields:dn(n.fields)};case c.LIST:return{...n,values:n.values.map(z)};case c.INT:case c.FLOAT:case c.STRING:case c.BOOLEAN:case c.NULL:case c.ENUM:case c.VARIABLE:return n}}function dn(n){return n.map(t=>({...t,value:z(t.value)})).sort((t,e)=>de(t.name.value,e.name.value))}function ye(n){return Array.isArray(n)?n.map(([t,e])=>`subfields "${t}" conflict because `+ye(e)).join(" and "):n}function pn(n){const t=new Oe,e=new Tn,r=new Map;return{SelectionSet(s){const i=mn(n,r,t,e,n.getParentType(),s);for(const[[o,a],l,u]of i){const f=ye(a);n.reportError(new p(`Fields "${o}" conflict because ${f}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:l.concat(u)}))}}}}function mn(n,t,e,r,s,i){const o=[],[a,l]=j(n,t,s,i);if(vn(n,o,t,e,r,a),l.length!==0)for(let u=0;u<l.length;u++){P(n,o,t,e,r,!1,a,l[u]);for(let f=u+1;f<l.length;f++)M(n,o,t,e,r,!1,l[u],l[f])}return o}function P(n,t,e,r,s,i,o,a){if(r.has(o,a,i))return;r.add(o,a,i);const l=n.getFragment(a);if(!l)return;const[u,f]=J(n,e,l);if(o!==u){Z(n,t,e,r,s,i,o,u);for(const d of f)P(n,t,e,r,s,i,o,d)}}function M(n,t,e,r,s,i,o,a){if(o===a||s.has(o,a,i))return;s.add(o,a,i);const l=n.getFragment(o),u=n.getFragment(a);if(!l||!u)return;const[f,d]=J(n,e,l),[m,g]=J(n,e,u);Z(n,t,e,r,s,i,f,m);for(const v of g)M(n,t,e,r,s,i,o,v);for(const v of d)M(n,t,e,r,s,i,v,a)}function gn(n,t,e,r,s,i,o,a,l){const u=[],[f,d]=j(n,t,i,o),[m,g]=j(n,t,a,l);Z(n,u,t,e,r,s,f,m);for(const v of g)P(n,u,t,e,r,s,f,v);for(const v of d)P(n,u,t,e,r,s,m,v);for(const v of d)for(const y of g)M(n,u,t,e,r,s,v,y);return u}function vn(n,t,e,r,s,i){for(const[o,a]of Object.entries(i))if(a.length>1)for(let l=0;l<a.length;l++)for(let u=l+1;u<a.length;u++){const f=he(n,e,r,s,!1,o,a[l],a[u]);f&&t.push(f)}}function Z(n,t,e,r,s,i,o,a){for(const[l,u]of Object.entries(o)){const f=a[l];if(f)for(const d of u)for(const m of f){const g=he(n,e,r,s,i,l,d,m);g&&t.push(g)}}}function he(n,t,e,r,s,i,o,a){const[l,u,f]=o,[d,m,g]=a,v=s||l!==d&&C(l)&&C(d);if(!v){const $=u.name.value,ne=m.name.value;if($!==ne)return[[i,`"${$}" and "${ne}" are different fields`],[u],[m]];if(!Nn(u,m))return[[i,"they have differing arguments"],[u],[m]]}const y=f?.type,R=g?.type;if(y&&R&&Q(y,R))return[[i,`they return conflicting types "${N(y)}" and "${N(R)}"`],[u],[m]];const x=u.selectionSet,ee=m.selectionSet;if(x&&ee){const $=gn(n,t,e,r,v,b(y),x,b(R),ee);return En($,i,u,m)}}function Nn(n,t){const e=n.arguments,r=t.arguments;if(e===void 0||e.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||e.length!==r.length)return!1;const s=new Map(r.map(({name:i,value:o})=>[i.value,o]));return e.every(i=>{const o=i.value,a=s.get(i.name.value);return a===void 0?!1:se(o)===se(a)})}function se(n){return T(z(n))}function Q(n,t){return F(n)?F(t)?Q(n.ofType,t.ofType):!0:F(t)?!0:I(n)?I(t)?Q(n.ofType,t.ofType):!0:I(t)?!0:A(n)||A(t)?n!==t:!1}function j(n,t,e,r){const s=t.get(r);if(s)return s;const i=Object.create(null),o=Object.create(null);be(n,e,r,i,o);const a=[i,Object.keys(o)];return t.set(r,a),a}function J(n,t,e){const r=t.get(e.selectionSet);if(r)return r;const s=h(n.getSchema(),e.typeCondition);return j(n,t,s,e.selectionSet)}function be(n,t,e,r,s){for(const i of e.selections)switch(i.kind){case c.FIELD:{const o=i.name.value;let a;(C(t)||V(t))&&(a=t.getFields()[o]);const l=i.alias?i.alias.value:o;r[l]||(r[l]=[]),r[l].push([t,i,a]);break}case c.FRAGMENT_SPREAD:s[i.name.value]=!0;break;case c.INLINE_FRAGMENT:{const o=i.typeCondition,a=o?h(n.getSchema(),o):t;be(n,a,i.selectionSet,r,s);break}}}function En(n,t,e,r){if(n.length>0)return[[t,n.map(([s])=>s)],[e,...n.map(([,s])=>s).flat()],[r,...n.map(([,,s])=>s).flat()]]}class Oe{constructor(){this._data=new Map}has(t,e,r){var s;const i=(s=this._data.get(t))===null||s===void 0?void 0:s.get(e);return i===void 0?!1:r?!0:r===i}add(t,e,r){const s=this._data.get(t);s===void 0?this._data.set(t,new Map([[e,r]])):s.set(e,r)}}class Tn{constructor(){this._orderedPairSet=new Oe}has(t,e,r){return t<e?this._orderedPairSet.has(t,e,r):this._orderedPairSet.has(e,t,r)}add(t,e,r){t<e?this._orderedPairSet.add(t,e,r):this._orderedPairSet.add(e,t,r)}}function In(n){return{InlineFragment(t){const e=n.getType(),r=n.getParentType();if(_(e)&&_(r)&&!te(n.getSchema(),e,r)){const s=N(r),i=N(e);n.reportError(new p(`Fragment cannot be spread here as objects of type "${s}" can never be of type "${i}".`,{nodes:t}))}},FragmentSpread(t){const e=t.name.value,r=yn(n,e),s=n.getParentType();if(r&&s&&!te(n.getSchema(),r,s)){const i=N(s),o=N(r);n.reportError(new p(`Fragment "${e}" cannot be spread here as objects of type "${i}" can never be of type "${o}".`,{nodes:t}))}}}}function yn(n,t){const e=n.getFragment(t);if(e){const r=h(n.getSchema(),e.typeCondition);if(_(r))return r}}function hn(n){return{...bn(n),Field:{leave(t){var e;const r=n.getFieldDef();if(!r)return!1;const s=new Set((e=t.arguments)===null||e===void 0?void 0:e.map(i=>i.name.value));for(const i of r.args)if(!s.has(i.name)&&pe(i)){const o=N(i.type);n.reportError(new p(`Field "${r.name}" argument "${i.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function bn(n){var t;const e=Object.create(null),r=n.getSchema(),s=(t=r?.getDirectives())!==null&&t!==void 0?t:G;for(const a of s)e[a.name]=k(a.args.filter(pe),l=>l.name);const i=n.getDocument().definitions;for(const a of i)if(a.kind===c.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];e[a.name.value]=k(l.filter(On),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=e[l];if(u){var f;const d=(f=a.arguments)!==null&&f!==void 0?f:[],m=new Set(d.map(g=>g.name.value));for(const[g,v]of Object.entries(u))if(!m.has(g)){const y=$e(v.type)?N(v.type):T(v.type);n.reportError(new p(`Directive "@${l}" argument "${g}" of type "${y}" is required, but it was not provided.`,{nodes:a}))}}}}}}function On(n){return n.type.kind===c.NON_NULL_TYPE&&n.defaultValue==null}function Dn(n){return{Field(t){const e=n.getType(),r=t.selectionSet;if(e)if(A(b(e))){if(r){const s=t.name.value,i=N(e);n.reportError(new p(`Field "${s}" must not have a selection since type "${i}" has no subfields.`,{nodes:r}))}}else if(r){if(r.selections.length===0){const s=t.name.value,i=N(e);n.reportError(new p(`Field "${s}" of type "${i}" must have at least one field selected.`,{nodes:t}))}}else{const s=t.name.value,i=N(e);n.reportError(new p(`Field "${s}" of type "${i}" must have a selection of subfields. Did you mean "${s} { ... }"?`,{nodes:t}))}}}}function Sn(n,t,e){var r;const s={},i=(r=t.arguments)!==null&&r!==void 0?r:[],o=k(i,a=>a.name.value);for(const a of n.args){const l=a.name,u=a.type,f=o[l];if(!f){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(I(u))throw new p(`Argument "${l}" of required type "${N(u)}" was not provided.`,{nodes:t});continue}const d=f.value;let m=d.kind===c.NULL;if(d.kind===c.VARIABLE){const v=d.name.value;if(e==null||!_n(e,v)){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(I(u))throw new p(`Argument "${l}" of required type "${N(u)}" was provided the variable "$${v}" which was not provided a runtime value.`,{nodes:d});continue}m=e[v]==null}if(m&&I(u))throw new p(`Argument "${l}" of non-null type "${N(u)}" must not be null.`,{nodes:d});const g=Fe(d,u,e);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${T(d)}.`,{nodes:d});s[l]=g}return s}function ae(n,t,e){var r;const s=(r=t.directives)===null||r===void 0?void 0:r.find(i=>i.name.value===n.name);if(s)return Sn(n,s,e)}function _n(n,t){return Object.prototype.hasOwnProperty.call(n,t)}function wn(n,t,e,r,s){const i=new Map;return H(n,t,e,r,s,i,new Set),i}function H(n,t,e,r,s,i,o){for(const a of s.selections)switch(a.kind){case c.FIELD:{if(!X(e,a))continue;const l=Rn(a),u=i.get(l);u!==void 0?u.push(a):i.set(l,[a]);break}case c.INLINE_FRAGMENT:{if(!X(e,a)||!oe(n,a,r))continue;H(n,t,e,r,a.selectionSet,i,o);break}case c.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!X(e,a))continue;o.add(l);const u=t[l];if(!u||!oe(n,u,r))continue;H(n,t,e,r,u.selectionSet,i,o);break}}}function X(n,t){const e=ae(Ve,t,n);if(e?.if===!0)return!1;const r=ae(Ce,t,n);return r?.if!==!1}function oe(n,t,e){const r=t.typeCondition;if(!r)return!0;const s=h(n,r);return s===e?!0:fe(s)?n.isSubType(s,e):!1}function Rn(n){return n.alias?n.alias.value:n.name.value}function $n(n){return{OperationDefinition(t){if(t.operation==="subscription"){const e=n.getSchema(),r=e.getSubscriptionType();if(r){const s=t.name?t.name.value:null,i=Object.create(null),o=n.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===c.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=wn(e,a,i,r,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();n.reportError(new p(s!=null?`Subscription "${s}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&n.reportError(new p(s!=null?`Subscription "${s}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function De(n,t){const e=new Map;for(const r of n){const s=t(r),i=e.get(s);i===void 0?e.set(s,[r]):i.push(r)}return e}function Fn(n){return{Field:t,Directive:t};function t(e){var r;const s=(r=e.arguments)!==null&&r!==void 0?r:[],i=De(s,o=>o.name.value);for(const[o,a]of i)a.length>1&&n.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Vn(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():G;for(const a of r)t[a.name]=!a.isRepeatable;const s=n.getDocument().definitions;for(const a of s)a.kind===c.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const i=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===c.SCHEMA_DEFINITION||a.kind===c.SCHEMA_EXTENSION)l=i;else if(K(a)||Ee(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const f=u.name.value;t[f]&&(l[f]?n.reportError(new p(`The directive "@${f}" can only be used once at this location.`,{nodes:[l[f],u]})):l[f]=u)}}}}function Cn(n){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(e){const r=e.name.value;return t[r]?n.reportError(new p(`There can be only one fragment named "${r}".`,{nodes:[t[r],e.name]})):t[r]=e.name,!1}}}function An(n){const t=[];let e=Object.create(null);return{ObjectValue:{enter(){t.push(e),e=Object.create(null)},leave(){const r=t.pop();r||D(!1),e=r}},ObjectField(r){const s=r.name.value;e[s]?n.reportError(new p(`There can be only one input field named "${s}".`,{nodes:[e[s],r.name]})):e[s]=r.name}}}function kn(n){const t=Object.create(null);return{OperationDefinition(e){const r=e.name;return r&&(t[r.value]?n.reportError(new p(`There can be only one operation named "${r.value}".`,{nodes:[t[r.value],r]})):t[r.value]=r),!1},FragmentDefinition:()=>!1}}function Ln(n){return{OperationDefinition(t){var e;const r=(e=t.variableDefinitions)!==null&&e!==void 0?e:[],s=De(r,i=>i.variable.name.value);for(const[i,o]of s)o.length>1&&n.reportError(new p(`There can be only one variable named "$${i}".`,{nodes:o.map(a=>a.variable.name)}))}}}function Un(n){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(e){t[e.variable.name.value]=e},ListValue(e){const r=ke(n.getParentInputType());if(!F(r))return O(n,e),!1},ObjectValue(e){const r=b(n.getInputType());if(!L(r))return O(n,e),!1;const s=k(e.fields,i=>i.name.value);for(const i of Object.values(r.getFields()))if(!s[i.name]&&Ae(i)){const a=N(i.type);n.reportError(new p(`Field "${r.name}.${i.name}" of required type "${a}" was not provided.`,{nodes:e}))}r.isOneOf&&Pn(n,e,r,s,t)},ObjectField(e){const r=b(n.getParentInputType());if(!n.getInputType()&&L(r)){const i=w(e.name.value,Object.keys(r.getFields()));n.reportError(new p(`Field "${e.name.value}" is not defined by type "${r.name}".`+S(i),{nodes:e}))}},NullValue(e){const r=n.getInputType();I(r)&&n.reportError(new p(`Expected value of type "${N(r)}", found ${T(e)}.`,{nodes:e}))},EnumValue:e=>O(n,e),IntValue:e=>O(n,e),FloatValue:e=>O(n,e),StringValue:e=>O(n,e),BooleanValue:e=>O(n,e)}}function O(n,t){const e=n.getInputType();if(!e)return;const r=b(e);if(!A(r)){const s=N(e);n.reportError(new p(`Expected value of type "${s}", found ${T(t)}.`,{nodes:t}));return}try{if(r.parseLiteral(t,void 0)===void 0){const i=N(e);n.reportError(new p(`Expected value of type "${i}", found ${T(t)}.`,{nodes:t}))}}catch(s){const i=N(e);s instanceof p?n.reportError(s):n.reportError(new p(`Expected value of type "${i}", found ${T(t)}; `+s.message,{nodes:t,originalError:s}))}}function Pn(n,t,e,r,s){var i;const o=Object.keys(r);if(o.length!==1){n.reportError(new p(`OneOf Input Object "${e.name}" must specify exactly one key.`,{nodes:[t]}));return}const l=(i=r[o[0]])===null||i===void 0?void 0:i.value,u=!l||l.kind===c.NULL,f=l?.kind===c.VARIABLE;if(u){n.reportError(new p(`Field "${e.name}.${o[0]}" must be non-null.`,{nodes:[t]}));return}if(f){const d=l.name.value;s[d].type.kind!==c.NON_NULL_TYPE&&n.reportError(new p(`Variable "${d}" must be non-nullable to be used for OneOf Input Object "${e.name}".`,{nodes:[t]}))}}function Mn(n){return{VariableDefinition(t){const e=h(n.getSchema(),t.type);if(e!==void 0&&!Le(e)){const r=t.variable.name.value,s=T(t.type);n.reportError(new p(`Variable "$${r}" cannot be non-input type "${s}".`,{nodes:t.type}))}}}}function jn(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s,type:i,defaultValue:o,parentType:a}of r){const l=s.name.value,u=t[l];if(u&&i){const f=n.getSchema(),d=h(f,u.type);if(d&&!Yn(f,d,u.defaultValue,i,o)){const m=N(d),g=N(i);n.reportError(new p(`Variable "$${l}" of type "${m}" used in position expecting type "${g}".`,{nodes:[u,s]}))}L(a)&&a.isOneOf&&Ue(d)&&n.reportError(new p(`Variable "$${l}" is of type "${d}" but must be non-nullable to be used for OneOf Input Object "${a}".`,{nodes:[u,s]}))}}}},VariableDefinition(e){t[e.variable.name.value]=e}}}function Yn(n,t,e,r,s){if(I(r)&&!I(t)){if(!(e!=null&&e.kind!==c.NULL)&&!(s!==void 0))return!1;const a=r.ofType;return re(n,t,a)}return re(n,t,r)}const Gn=Object.freeze([ln]),Se=Object.freeze([Te,kn,an,$n,rn,Ke,Mn,Dn,Je,Cn,tn,Ie,In,un,Ln,cn,fn,xe,Vn,ze,Fn,Un,hn,jn,pn,An,...Gn]);class Bn{constructor(t,e){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=e}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let e;if(this._fragments)e=this._fragments;else{e=Object.create(null);for(const r of this.getDocument().definitions)r.kind===c.FRAGMENT_DEFINITION&&(e[r.name.value]=r);this._fragments=e}return e[t]}getFragmentSpreads(t){let e=this._fragmentSpreads.get(t);if(!e){e=[];const r=[t];let s;for(;s=r.pop();)for(const i of s.selections)i.kind===c.FRAGMENT_SPREAD?e.push(i):i.selectionSet&&r.push(i.selectionSet);this._fragmentSpreads.set(t,e)}return e}getRecursivelyReferencedFragments(t){let e=this._recursivelyReferencedFragments.get(t);if(!e){e=[];const r=Object.create(null),s=[t.selectionSet];let i;for(;i=s.pop();)for(const o of this.getFragmentSpreads(i)){const a=o.name.value;if(r[a]!==!0){r[a]=!0;const l=this.getFragment(a);l&&(e.push(l),s.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,e)}return e}}class qn extends Bn{constructor(t,e,r,s){super(e,s),this._schema=t,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let e=this._variableUsages.get(t);if(!e){const r=[],s=new me(this._schema);ge(t,ve(s,{VariableDefinition:()=>!1,Variable(i){r.push({node:i,type:s.getInputType(),defaultValue:s.getDefaultValue(),parentType:s.getParentInputType()})}})),e=r,this._variableUsages.set(t,e)}return e}getRecursiveVariableUsages(t){let e=this._recursiveVariableUsages.get(t);if(!e){e=this.getVariableUsages(t);for(const r of this.getRecursivelyReferencedFragments(t))e=e.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(t,e)}return e}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function _e(n,t,e=Se,r,s=new me(n)){var i;const o=(i=void 0)!==null&&i!==void 0?i:100;t||Pe(!1,"Must provide document."),Me(n);const a=Object.freeze({}),l=[],u=new qn(n,t,s,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),f=je(e.map(d=>d(u)));try{ge(t,ve(s,f))}catch(d){if(d!==a)throw d}return l}function Xn(n){return{Field(t){const e=n.getFieldDef(),r=e?.deprecationReason;if(e&&r!=null){const s=n.getParentType();s!=null||D(!1),n.reportError(new p(`The field ${s.name}.${e.name} is deprecated. ${r}`,{nodes:t}))}},Argument(t){const e=n.getArgument(),r=e?.deprecationReason;if(e&&r!=null){const s=n.getDirective();if(s!=null)n.reportError(new p(`Directive "@${s.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}));else{const i=n.getParentType(),o=n.getFieldDef();i!=null&&o!=null||D(!1),n.reportError(new p(`Field "${i.name}.${o.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}))}}},ObjectField(t){const e=b(n.getParentInputType());if(L(e)){const r=e.getFields()[t.name.value],s=r?.deprecationReason;s!=null&&n.reportError(new p(`The input field ${e.name}.${r.name} is deprecated. ${s}`,{nodes:t}))}},EnumValue(t){const e=n.getEnumValue(),r=e?.deprecationReason;if(e&&r!=null){const s=b(n.getInputType());s!=null||D(!1),n.reportError(new p(`The enum value "${s.name}.${e.name}" is deprecated. ${r}`,{nodes:t}))}}}}function Qn(n,t,e,r,s){const i=Se.filter(a=>!(a===Ie||a===Te));return e&&Array.prototype.push.apply(i,e),_e(n,t,i).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===c.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}const le={Error:"Error",Warning:"Warning"},W={[le.Error]:1,[le.Warning]:2},Y=(n,t)=>{if(!n)throw new Error(t)};function Jn(n,t=null,e,r,s){var i,o;let a=null,l="";s&&(l=typeof s=="string"?s:s.reduce((f,d)=>f+T(d)+`

`,""));const u=l?`${n}

${l}`:n;try{a=Ye(u)}catch(f){if(f instanceof p){const d=Wn((o=(i=f.locations)===null||i===void 0?void 0:i[0])!==null&&o!==void 0?o:{line:0},u);return[{severity:W.Error,message:f.message,source:"GraphQL: Syntax",range:d}]}throw f}return Hn(a,t,e)}function Hn(n,t=null,e,r){if(!t)return[];const s=Qn(t,n,e).flatMap(o=>ue(o,W.Error,"Validation")),i=_e(t,n,[Xn]).flatMap(o=>ue(o,W.Warning,"Deprecation"));return s.concat(i)}function ue(n,t,e){if(!n.nodes)return[];const r=[];for(const[s,i]of n.nodes.entries()){const o=i.kind!=="Variable"&&"name"in i&&i.name!==void 0?i.name:"variable"in i&&i.variable!==void 0?i.variable:i;if(o){Y(n.locations,"GraphQL validation error requires locations.");const a=n.locations[s],l=Kn(o),u=a.column+(l.end-l.start);r.push({source:`GraphQL: ${e}`,message:n.message,severity:t,range:new Ne(new U(a.line-1,a.column-1),new U(a.line-1,u))})}}return r}function Wn(n,t){const e=Ge(),r=e.startState(),s=t.split(`
`);Y(s.length>=n.line,"Query text must have more lines than where the error happened");let i=null;for(let u=0;u<n.line;u++)for(i=new Be(s[u]);!i.eol()&&e.token(i,r)!=="invalidchar";);Y(i,"Expected Parser stream to be available.");const o=n.line-1,a=i.getStartOfToken(),l=i.getCurrentPosition();return new Ne(new U(o,a),new U(o,l))}function Kn(n){const e=n.loc;return Y(e,"Expected ASTNode to have a location."),e}const ce=["error","warning","information","hint"],zn={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};B.registerHelper("lint","graphql",(n,t)=>{const{schema:e,validationRules:r,externalFragments:s}=t;return Jn(n,e,r,void 0,s).map(a=>({message:a.message,severity:a.severity?ce[a.severity-1]:ce[0],type:a.source?zn[a.source]:void 0,from:B.Pos(a.range.start.line,a.range.start.character),to:B.Pos(a.range.end.line,a.range.end.character)}))});
